/**
 * Project Parthora's main game scene.
 *
 * @date       March 9, 2015
 *
 * @revisions
 *
 * @designer   Melvin Loho
 *
 * @programmer Melvin Loho
 *
 * @notes
 */

// NOTES:
// 1) sf::Mouse::setPosition(pos, window);
// 2) getWindow().pollEvent(dummyEvent);
// SFML hack: it prevents an infinite recursion by capturing the sf::Event generated by sf::Mouse::setPosition

#include "ParticleSystemPlayground.h"

#include "../engine/AppWindow.h"
#include "../graphics/Fireball.h"
#include "../GameSettings.h"
#include "../net/PacketCreator.h"

#include <iostream>

using namespace std;

sf::Event dummyEvent;

ParticleSystemPlayground::ParticleSystemPlayground(AppWindow &window) :
Scene(window, "Melvin Loho"), renderer(window, 1000), me(nullptr)
{
	//conn.setReceiveHandler(std::bind(&ParticleSystemPlayground::onReceive, this, std::placeholders::_1));

	particleTexture.loadFromFile("Data/textures/particle_1.tga");
	particleTexture.setSmooth(true);

	bgm.openFromFile("Data/audio/gardenparty_mono.wav");
}

ParticleSystemPlayground::~ParticleSystemPlayground()
{
	unload();
}

void ParticleSystemPlayground::onload()
{
	view_hud = view_main = getWindow().getCurrentView();

	sf::Vector2f center = view_main.getCenter();

	cout << "Connecting to..." << GameSettings::toString() << endl;

	if (conn.start(GameSettings::serverIP, GameSettings::serverPort))
	{
		cout << "Connected to the server!" << endl;
	}
	else
	{
		cerr << "Failed to connect to the server!" << endl;
	}

	createPlayer(Client::ID_MYSELF, sf::IpAddress::getLocalAddress().toString(), new Fireball(getWindow(), view_main), particleTexture);

	me->ps->emitterPos = center;
	sf::Mouse::setPosition(sf::Vector2i(center), getWindow());
	getWindow().pollEvent(dummyEvent);

	setControlParticle(false);
	setControlParticle(isControllingParticle = true);

	sf::Listener::setPosition(center.x, center.y, -100);
	bgm.setPosition(center.x, center.y, 0);
	bgm.setMinDistance(1000);
	bgm.setLoop(true);

	conn.send(PacketCreator::Get().PlayerInfo(getWindow().getSize(), getDCPFromPlayer(me)));
}

void ParticleSystemPlayground::unload()
{
	getWindow().setMouseCursorVisible(true);

	bgm.stop();

	for (Player* player : players)
	{
		delete player->ps;
	}
	players.clear();

	conn.stop();
}

void ParticleSystemPlayground::handleEvent(const sf::Event &event)
{
	Scene::handleEvent(event);

	static bool vSync = false, particleBuilder = false, music1Toggle = false;
	//static float view_main_offset_value = 5, view_main_offset_max = 15;

	switch (event.type)
	{
	case sf::Event::MouseMoved:
	{
		if (isControllingParticle)
		{
			sf::Vector2f delta = getWindow().getMousePositionRelativeToWindowAndView(view_main) - view_main.getCenter();
			sf::Mouse::setPosition(sf::Vector2i(view_main.getCenter()), getWindow());
			getWindow().pollEvent(dummyEvent);

			if (me != nullptr)
			{
				me->ps->emitterPos += delta;
			}

			// send a position update packet to server
			conn.send(PacketCreator::Get().PlayerPos(delta));
		}
	}
	break;

	case sf::Event::MouseWheelMoved:
		//view_main.zoom(1 - event.mouseWheel.delta * 0.0625f);
		break;

		/*
		case sf::Event::KeyPressed:
		switch (event.key.code)
		{
		case sf::Keyboard::A:
		if (view_main_offset.x > -view_main_offset_max)
		view_main_offset.x += -view_main_offset_value;
		break;
		case sf::Keyboard::D:
		if (view_main_offset.x < view_main_offset_max)
		view_main_offset.x += view_main_offset_value;
		break;
		case sf::Keyboard::W:
		if (view_main_offset.y > -view_main_offset_max)
		view_main_offset.y += -view_main_offset_value;
		break;
		case sf::Keyboard::S:
		if (view_main_offset.y < view_main_offset_max)
		view_main_offset.y += view_main_offset_value;
		break;
		}
		break;
		*/

	case sf::Event::KeyReleased:
		switch (event.key.code)
		{
		case sf::Keyboard::BackSpace:
			//getWindow().removeScene(this->getID());
			break;
		case sf::Keyboard::Space:
			setControlParticle(isControllingParticle = !isControllingParticle);
			break;
		case sf::Keyboard::Delete:
			for (Player* player : players)
			{
				player->ps->clear();
			}
			break;

			/*
			case sf::Keyboard::A:
			case sf::Keyboard::D:
			view_main_offset.x = 0;
			break;
			case sf::Keyboard::W:
			case sf::Keyboard::S:
			view_main_offset.y = 0;
			break;
			*/

		case sf::Keyboard::V:
			getWindow().setVerticalSyncEnabled(vSync = !vSync);
			break;
		case sf::Keyboard::P:
			if (me)
			{
				randomizeParticleColors(me);
			}
			break;
		case sf::Keyboard::M:
			music1Toggle = !music1Toggle;
			if (music1Toggle) bgm.play();
			else bgm.stop();
			break;
		}
		break;

	case sf::Event::Resized:
		view_hud = getWindow().getCurrentView();
		view_main.setSize(view_hud.getSize());
		view_main.setCenter(getWindow().getSize().x * 0.5f, getWindow().getSize().y * 0.5f);

		getWindow().setMousePositionRelativeToWindowAndView(view_main.getCenter(), view_main);
		getWindow().pollEvent(dummyEvent);
		break;
	}
}

void ParticleSystemPlayground::update(const sf::Time &deltaTime)
{
	//view_main.move(view_main_offset);

	ParticleSystem::TotalParticleCount = 0;

	for (const Packet& pendingPacket : conn.getPendingPackets())
	{
		onReceive(pendingPacket);
	}

	for (Player* player : players)
	{
		player->ps->update(deltaTime);
	}

	scene_log.text().setString(
		getWindow().getName() + " by " + getName()
		+ "\n"
		+ "\n"
		+ "[FPS]: " + std::to_string(getWindow().getFPS())
		+ "\n"
		+ "\n[RENDERER]"
		+ "\nDraw calls: " + std::to_string(renderer.getDrawCallCount())
		+ "\nSprites   : " + std::to_string(renderer.getSpriteCount())
		+ "\n"
		+ "\n[PARTICLES]"
		+ "\nTotal: " + std::to_string(ParticleSystem::TotalParticleCount)
		);

	for (Player* player : players)
	{
		scene_log.text().setString(scene_log.text().getString() + "\n>" + player->label.text().getString() + ": " + std::to_string(player->ps->getParticleCount()));
	}
}

void ParticleSystemPlayground::render()
{
	getWindow().clear();

	renderer.resetStats();

	getWindow().setView(view_main); ///////////////////////////////////

	renderer.begin();

	for (Player* player : players)
	{
		renderer.draw(player->ps);
	}

	renderer.end();

	getWindow().setView(view_hud); ////////////////////////////////////

	renderer.begin();

	renderer.draw(scene_log);

	renderer.end();

	getWindow().display();
}

void ParticleSystemPlayground::randomizeParticleColors(Player* player)
{
	player->ps->colorBegin = sf::Color(rand() & 255, rand() & 255, rand() & 255);
	player->ps->colorEnd = sf::Color(rand() & 255, rand() & 255, rand() & 255);

	conn.send(PacketCreator::Get().PlayerInfo(getWindow().getSize(), getDCPFromPlayer(player)));
}

void ParticleSystemPlayground::setControlParticle(bool arg)
{
	if (arg)
	{
		getWindow().setMouseCursorVisible(false);

		getWindow().setMousePositionRelativeToWindowAndView(view_main.getCenter(), view_main);
		getWindow().pollEvent(dummyEvent);
	}
	else
	{
		getWindow().setMouseCursorVisible(true);
	}
}

Player* ParticleSystemPlayground::createPlayer(Client::ID id, std::string name, ParticleSystem* ps, const sf::Texture& texture)
{
	Player* newPlayer = nullptr;

	// check if player already exists
	for (Player* player : players)
	{
		if (player->id == id)
		{
			newPlayer = player;
			delete newPlayer->ps;
		}
	}

	// create new player if they're not found
	if (newPlayer == nullptr)
	{
		players.push_back(new Player());

		newPlayer = players.back();
	}

	newPlayer->id = id;

	newPlayer->ps = ps;
	newPlayer->ps->setTexture(texture);

	newPlayer->label.text().setFont(*scene_log.text().getFont());
	newPlayer->label.text().setCharacterSize(15);
	newPlayer->label.text().setPosition(10, -10);
	newPlayer->label.text().setString(name);

	newPlayer->ps->add(newPlayer->label);

	if (id == Client::ID_MYSELF)
	{
		me = newPlayer;
	}

	cout << "Player added! ID: " << id << endl;

	return newPlayer;
}

DynamicClientParams ParticleSystemPlayground::getDCPFromPlayer(const Player* player)
{
	DynamicClientParams dcp;

	dcp.name = player->label.text().getString().toAnsiString();
	dcp.ps.colorBegin = player->ps->colorBegin;
	dcp.ps.colorEnd = player->ps->colorEnd;
	dcp.ps.emitterPos = player->ps->emitterPos;

	return dcp;
}

void ParticleSystemPlayground::onReceive(const Packet& receivedPacket)
{

	if (receivedPacket.mType != PLAYER_POS)
		cout << "onReceive> " << receivedPacket.toString() << endl;


	switch (receivedPacket.mType)
	{
	case PLAYER_NEW:
	{
		Player* newPlayer = createPlayer(receivedPacket.get<Client::ID>(0), receivedPacket.get(4), new Fireball(getWindow(), view_main), particleTexture);
		Cross crossDir = static_cast<Cross>(receivedPacket.get<int>(1));

		switch (crossDir)
		{
		case CROSS_LEFT:
			newPlayer->ps->emitterPos.x = getWindow().getSize().x + receivedPacket.get<float>(2);
			break;
		case CROSS_RIGHT:
			newPlayer->ps->emitterPos.x = 0 - receivedPacket.get<float>(2);
			break;
		}

		newPlayer->ps->emitterPos.y = receivedPacket.get<float>(3) * getWindow().getSize().y;

		newPlayer->ps->colorBegin = sf::Color(receivedPacket.get<sf::Uint32>(5), receivedPacket.get<sf::Uint32>(6), receivedPacket.get<sf::Uint32>(7), receivedPacket.get<sf::Uint32>(8));
		newPlayer->ps->colorEnd = sf::Color(receivedPacket.get<sf::Uint32>(9), receivedPacket.get<sf::Uint32>(10), receivedPacket.get<sf::Uint32>(11), receivedPacket.get<sf::Uint32>(12));
	}
	break;

	case PLAYER_DEL:
	{
		Client::ID clientID = receivedPacket.get<Client::ID>(0);

		for (std::vector<Player*>::iterator it = players.begin(); it != players.end();)
		{
			if ((*it)->id == clientID)
			{
				delete (*it)->ps;
				delete (*it);

				it = players.erase(it);

				cout << "onReceive> Player removed! ID: " << clientID << endl;
				return;
			}
			else
			{
				++it;
			}
		}

		cout << "onReceive> Player to remove not found! ID: " << clientID << endl;
	}
	break;

	case PLAYER_POS:
		for (Player* player : players)
		{
			if (player->id == receivedPacket.get<Client::ID>(2))
			{
				player->ps->emitterPos.x += receivedPacket.get<float>(0);
				player->ps->emitterPos.y += receivedPacket.get<float>(1);
				return;
			}
		}
		break;
	}
}
