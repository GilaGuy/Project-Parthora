/**
 * Project Parthora's main game scene.
 *
 * @date       March 9, 2015
 *
 * @revisions
 *
 * @designer   Melvin Loho
 *
 * @programmer Melvin Loho
 *
 * @notes
 */

#include "ParticleSystemPlayground.h"

#include "../engine/AppWindow.h"
#include "../graphics/Fireball.h"

#include <iostream>

using namespace std;

ParticleSystemPlayground::ParticleSystemPlayground(AppWindow &window) :
Scene(window, "Particle System Playground"), renderer(window, 1000), me(nullptr)
{
	//conn.setReceiveHandler(std::bind(&ParticleSystemPlayground::onReceive, this, std::placeholders::_1));

	particleTexture.loadFromFile("Data/textures/particle_1.tga");
	particleTexture.setSmooth(true);

	bgm.openFromFile("D:/Dropbox/SFML-Game - backup/SFML-Game/Data/audio/gardenparty_mono.wav");
}

ParticleSystemPlayground::~ParticleSystemPlayground()
{
	unload();
}

void ParticleSystemPlayground::onload()
{
	view_hud = view_main = getWindow().getCurrentView();

	sf::Vector2f center = view_main.getCenter();

	if (conn.start("localhost", 12345))
	{
		cout << "Connected to the server!" << endl;
	}
	else
	{
		cerr << "Failed to connect to the server!" << endl;
	}

	createPlayer(Client::ID_MYSELF, sf::IpAddress::getLocalAddress().toString(), new Fireball(getWindow(), view_main), particleTexture);

	me->ps->emitterPos = center;
	sf::Mouse::setPosition(sf::Vector2i(center), getWindow());
	getWindow().pollEvent(sf::Event()); // <-- SFML hack: it prevents an infinite recursion by capturing the sf::Event generated by sf::Mouse::setPosition

	setControlParticle(false);
	setControlParticle(isControllingParticle = true);

	Packet p;

	createPlayerInfoPacket(me, p);

	sf::Listener::setPosition(center.x, center.y, -100);
	bgm.setPosition(center.x, center.y, 0);
	bgm.setMinDistance(1000);
	bgm.setLoop(true);

	conn.send(p);
}

void ParticleSystemPlayground::unload()
{
	getWindow().setMouseCursorVisible(true);

	bgm.stop();

	for (Player* player : players)
	{
		delete player->ps;
	}
	players.clear();

	conn.stop();
}

void ParticleSystemPlayground::handleEvent(const sf::Event &event)
{
	Scene::handleEvent(event);

	static bool vSync = false, particleBuilder = false, music1Toggle = false;
	//static float view_main_offset_value = 5, view_main_offset_max = 15;

	switch (event.type)
	{
	case sf::Event::MouseMoved:
	{
		if (isControllingParticle)
		{
			sf::Vector2f delta = getWindow().getMousePositionRelativeToWindowAndView(view_main) - view_main.getCenter();
			sf::Mouse::setPosition(sf::Vector2i(view_main.getCenter()), getWindow());
			getWindow().pollEvent(sf::Event()); // <-- SFML hack: it prevents an infinite recursion by capturing the sf::Event generated by sf::Mouse::setPosition

			if (me != nullptr)
			{
				me->ps->emitterPos += delta;
			}

			// send an UPDATE_POS packet to server
			Packet p;
			p.mType = UPDATE_POS;
			p.add(delta.x);
			p.add(delta.y);
			conn.send(p);
		}
	}
	break;

	case sf::Event::MouseWheelMoved:
		view_main.zoom(1 - event.mouseWheel.delta * 0.0625f);
		break;

		/*
		case sf::Event::KeyPressed:
		switch (event.key.code)
		{
		case sf::Keyboard::A:
		if (view_main_offset.x > -view_main_offset_max)
		view_main_offset.x += -view_main_offset_value;
		break;
		case sf::Keyboard::D:
		if (view_main_offset.x < view_main_offset_max)
		view_main_offset.x += view_main_offset_value;
		break;
		case sf::Keyboard::W:
		if (view_main_offset.y > -view_main_offset_max)
		view_main_offset.y += -view_main_offset_value;
		break;
		case sf::Keyboard::S:
		if (view_main_offset.y < view_main_offset_max)
		view_main_offset.y += view_main_offset_value;
		break;
		}
		break;
		*/

	case sf::Event::KeyReleased:
		switch (event.key.code)
		{
		case sf::Keyboard::BackSpace:
			//getWindow().removeScene(this->getID());
			break;
		case sf::Keyboard::Space:
			setControlParticle(isControllingParticle = !isControllingParticle);
			break;
		case sf::Keyboard::Delete:
			for (Player* player : players)
			{
				player->ps->clear();
			}
			break;

			/*
			case sf::Keyboard::A:
			case sf::Keyboard::D:
			view_main_offset.x = 0;
			break;
			case sf::Keyboard::W:
			case sf::Keyboard::S:
			view_main_offset.y = 0;
			break;
			*/

		case sf::Keyboard::V:
			getWindow().setVerticalSyncEnabled(vSync = !vSync);
			break;
		case sf::Keyboard::P:
			if (me)
			{
				randomizeParticleColors(me);
			}
			break;
		case sf::Keyboard::M:
			music1Toggle = !music1Toggle;
			if (music1Toggle) bgm.stop();
			else bgm.play();
			break;
		}
		break;

	case sf::Event::Resized:
		view_hud = getWindow().getCurrentView();
		view_main.setSize(view_hud.getSize());
		view_main.setCenter(getWindow().getSize().x * 0.5f, getWindow().getSize().y * 0.5f);
		break;
	}
}

void ParticleSystemPlayground::update(const sf::Time &deltaTime)
{
	//view_main.move(view_main_offset);

	for (const Packet& p : conn.getPendingPackets())
	{
		onReceive(p);
	}

	for (Player* player : players)
	{
		player->ps->update(deltaTime);
	}

	scene_log.text().setString(
		"[FPS]: " + std::to_string(getWindow().getFPS())
		+ "\n"
		+ "\n[RENDERER]"
		+ "\nDraw calls: " + std::to_string(renderer.getDrawCallCount())
		+ "\nSprites   : " + std::to_string(renderer.getSpriteCount())
		+ "\n"
		+ "\n[PARTICLES]"
		+ "\nTotal: " + std::to_string(ParticleSystem::TotalParticleCount)
		);

	for (Player* player : players)
	{
		scene_log.text().setString(scene_log.text().getString() + "\n>" + player->label.text().getString() + ": " + std::to_string(player->ps->getParticleCount()));
	}
}

void ParticleSystemPlayground::render()
{
	getWindow().clear();

	renderer.resetStats();

	getWindow().setView(view_main); ///////////////////////////////////

	renderer.begin();

	for (Player* player : players)
	{
		renderer.draw(player->ps);
	}

	renderer.end();

	getWindow().setView(view_hud); ////////////////////////////////////

	renderer.begin();

	renderer.draw(scene_log);

	renderer.end();

	getWindow().display();
}

void ParticleSystemPlayground::randomizeParticleColors(Player* player)
{
	player->ps->colorBegin = sf::Color(rand() & 255, rand() & 255, rand() & 255);
	player->ps->colorEnd = sf::Color(rand() & 255, rand() & 255, rand() & 255);

	Packet p;
	createPlayerInfoPacket(player, p);
	conn.send(p);
}

void ParticleSystemPlayground::setControlParticle(bool arg)
{
	if (arg)
	{
		getWindow().setMouseCursorVisible(false);

		getWindow().setMousePositionRelativeToWindowAndView(lastPos, view_main);
		getWindow().pollEvent(sf::Event());
	}
	else
	{
		lastPos = getWindow().getMousePositionRelativeToWindowAndView(view_main);

		getWindow().setMouseCursorVisible(true);
	}
}

void ParticleSystemPlayground::createPlayerInfoPacket(const Player* player, Packet& p)
{
	p.mType = PLAYER_INFO;

	p.mParams.clear();

	p.add(player->label.text().getString().toAnsiString());

	sf::Vector2u size = getWindow().getSize();
	p.add(size.x);
	p.add(size.y);

	p.add(player->ps->emitterPos.x);
	p.add(player->ps->emitterPos.y);

	p.add<sf::Uint32>(player->ps->colorBegin.r);
	p.add<sf::Uint32>(player->ps->colorBegin.g);
	p.add<sf::Uint32>(player->ps->colorBegin.b);
	p.add<sf::Uint32>(player->ps->colorBegin.a);

	p.add<sf::Uint32>(player->ps->colorEnd.r);
	p.add<sf::Uint32>(player->ps->colorEnd.g);
	p.add<sf::Uint32>(player->ps->colorEnd.b);
	p.add<sf::Uint32>(player->ps->colorEnd.a);
}

Player* ParticleSystemPlayground::createPlayer(Client::ID id, std::string name, ParticleSystem* ps, const sf::Texture& texture)
{
	Player* newPlayer = nullptr;

	// check if player already exists
	for (Player* p : players)
	{
		if (p->id == id)
		{
			newPlayer = p;
			delete newPlayer->ps;
		}
	}

	// create new player if they're not found
	if (newPlayer == nullptr)
	{
		players.push_back(new Player());

		newPlayer = players.back();
	}

	newPlayer->id = id;

	newPlayer->ps = ps;
	newPlayer->ps->setTexture(texture);

	newPlayer->label.text().setFont(*scene_log.text().getFont());
	newPlayer->label.text().setCharacterSize(15);
	newPlayer->label.text().setPosition(10, -10);
	newPlayer->label.text().setString(name);

	newPlayer->ps->add(newPlayer->label);

	if (id == Client::ID_MYSELF)
	{
		me = newPlayer;
	}

	cout << "Player added! ID: " << id << endl;

	return newPlayer;
}

void ParticleSystemPlayground::onReceive(const Packet& p)
{

	if (p.mType != UPDATE_POS)
		cout << "recv> " << p.encode() << endl;


	switch (p.mType)
	{
	case NEW_PLAYER:
	{
		Player* newPlayer = createPlayer(p.get<Client::ID>(0), p.get(4), new Fireball(getWindow(), view_main), particleTexture);
		Cross crossDir = static_cast<Cross>(p.get<int>(1));

		switch (crossDir)
		{
		case CROSS_LEFT:
			newPlayer->ps->emitterPos.x = getWindow().getSize().x + p.get<float>(2);
			break;
		case CROSS_RIGHT:
			newPlayer->ps->emitterPos.x = 0 - p.get<float>(2);
			break;
		}

		newPlayer->ps->emitterPos.y = p.get<float>(3) * getWindow().getSize().y;

		newPlayer->ps->colorBegin = sf::Color(p.get<sf::Uint32>(5), p.get<sf::Uint32>(6), p.get<sf::Uint32>(7), p.get<sf::Uint32>(8));
		newPlayer->ps->colorEnd = sf::Color(p.get<sf::Uint32>(9), p.get<sf::Uint32>(10), p.get<sf::Uint32>(11), p.get<sf::Uint32>(12));
	}
	break;

	case DELETE_PLAYER:
	{
		Client::ID clientID = p.get<Client::ID>(0);

		for (std::vector<Player*>::iterator it = players.begin(); it != players.end();)
		{
			if ((*it)->id == clientID)
			{
				delete (*it)->ps;
				delete (*it);

				it = players.erase(it);
				return;
			}
		}
	}
	break;

	case UPDATE_POS:
		for (Player* player : players)
		{
			if (player->id == p.get<Client::ID>(2))
			{
				player->ps->emitterPos.x += p.get<float>(0);
				player->ps->emitterPos.y += p.get<float>(1);
				return;
			}
		}
		break;
	}
}
