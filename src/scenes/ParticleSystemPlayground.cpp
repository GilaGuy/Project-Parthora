/**
 * Project Parthora's main game scene.
 *
 * @date       March 9, 2015
 *
 * @revisions
 *
 * @designer   Melvin Loho
 *
 * @programmer Melvin Loho
 *
 * @notes
 */

 // NOTES:
 // 1) sf::Mouse::setPosition(pos, window);
 // 2) getWindow().pollEvent(dummyEvent);
 // SFML hack: it prevents an infinite recursion by capturing the sf::Event generated by sf::Mouse::setPosition

#include "ParticleSystemPlayground.h"

#include "../engine/AppWindow.h"
#include "../graphics/Fireball.h"
#include "../GameSettings.h"
#include "../net/PacketCreator.h"

#include <iostream>

using namespace std;

sf::Event dummyEvent;

ParticleSystemPlayground::ParticleSystemPlayground(AppWindow &window) :
	Scene(window, "Melvin Loho"), renderer(window, 1000), me(nullptr)
{
	conn.setConnectHandler(std::bind(&ParticleSystemPlayground::onConnect, this));
	//conn.setReceiveHandler(std::bind(&ParticleSystemPlayground::onReceive, this, std::placeholders::_1));
	conn.setDisconnectHandler(std::bind(&ParticleSystemPlayground::onDisconnect, this));

	particleTexture.loadFromFile("Data/textures/particle_1.tga");
	particleTexture.setSmooth(true);

	bgm.openFromFile("Data/audio/gardenparty_mono.wav");
}

ParticleSystemPlayground::~ParticleSystemPlayground()
{
	unload();
}

void ParticleSystemPlayground::onload()
{
	view_hud = view_main = getWindow().getCurrentView();

	sf::Vector2f center = view_main.getCenter();

	cout << "Connecting to..." << GameSettings::toString() << endl;

	if (!conn.start(GameSettings::serverIP, GameSettings::serverPort))
	{
		cerr << "Failed to connect to the server!" << endl;
	}

	createPlayer(Client::MYSELF, sf::IpAddress::getLocalAddress().toString(), new Fireball(getWindow(), view_main), particleTexture);

	me->ps->emitterPos = center;
	sf::Mouse::setPosition(sf::Vector2i(center), getWindow());
	getWindow().pollEvent(dummyEvent);

	setControlParticle(isControllingParticle = false);

	sf::Listener::setPosition(center.x, center.y, -100);
	bgm.setPosition(center.x, center.y, 0);
	bgm.setMinDistance(1000);
	bgm.setLoop(true);

	myScreen.size = getWindow().getSize();
	conn.send(PacketCreator::Get().PlayerInfo(getClientParams(me), myScreen));
}

void ParticleSystemPlayground::unload()
{
	getWindow().setMouseCursorVisible(true);

	bgm.stop();

	for (Player* player : players)
	{
		delete player->ps;
	}
	players.clear();

	conn.stop();
}

void ParticleSystemPlayground::updateViews()
{
	view_hud = getWindow().getCurrentView();
	view_main.setSize(view_hud.getSize());
	view_main.setCenter(getWindow().getSize().x * 0.5f, getWindow().getSize().y * 0.5f);
}

void ParticleSystemPlayground::handleEvent(const sf::Event &event)
{
	Scene::handleEvent(event);

	static bool vSync = false, particleBuilder = false, music1Toggle = false;
	//static float view_main_offset_value = 5, view_main_offset_max = 15;

	switch (event.type)
	{
	case sf::Event::MouseMoved:
	{
		if (isControllingParticle)
		{
			sf::Vector2f delta = getWindow().getMousePositionRelativeToWindowAndView(view_main) - view_main.getCenter();
			sf::Mouse::setPosition(sf::Vector2i(view_main.getCenter()), getWindow());
			getWindow().pollEvent(dummyEvent);

			// send a position update packet to server if my player is available
			if (me)
			{
				if (delta.x != 0 || delta.y != 0)
					conn.send(PacketCreator::Get().PlayerMove(delta));
			}
		}
	}
	break;

	case sf::Event::MouseWheelMoved:
		//view_main.zoom(1 - event.mouseWheel.delta * 0.0625f);
		break;

		/*
		case sf::Event::KeyPressed:
		switch (event.key.code)
		{
		case sf::Keyboard::A:
		if (view_main_offset.x > -view_main_offset_max)
		view_main_offset.x += -view_main_offset_value;
		break;
		case sf::Keyboard::D:
		if (view_main_offset.x < view_main_offset_max)
		view_main_offset.x += view_main_offset_value;
		break;
		case sf::Keyboard::W:
		if (view_main_offset.y > -view_main_offset_max)
		view_main_offset.y += -view_main_offset_value;
		break;
		case sf::Keyboard::S:
		if (view_main_offset.y < view_main_offset_max)
		view_main_offset.y += view_main_offset_value;
		break;
		}
		break;
		*/

	case sf::Event::KeyReleased:
		switch (event.key.code)
		{
		case sf::Keyboard::BackSpace:
			//getWindow().removeScene(this->getID());
			break;
		case sf::Keyboard::Space:
			setControlParticle(isControllingParticle = !isControllingParticle);
			break;
		case sf::Keyboard::Delete:
			for (Player* player : players)
			{
				player->ps->clear();
			}
			break;

			/*
			case sf::Keyboard::A:
			case sf::Keyboard::D:
			view_main_offset.x = 0;
			break;
			case sf::Keyboard::W:
			case sf::Keyboard::S:
			view_main_offset.y = 0;
			break;
			*/

		case sf::Keyboard::V:
			getWindow().setVerticalSyncEnabled(vSync = !vSync);
			break;
		case sf::Keyboard::P:
			if (me)
			{
				randomizeParticleColors(me);
			}
			break;
		case sf::Keyboard::M:
			music1Toggle = !music1Toggle;
			if (music1Toggle) bgm.play();
			else bgm.stop();
			break;
		}
		break;

	case sf::Event::Resized:
		updateViews();
		break;
	}
}

void ParticleSystemPlayground::update(const sf::Time &deltaTime)
{
	ParticleSystem::TotalParticleCount = 0;

	for (const Packet& pendingPacket : conn.getPendingPackets())
	{
		onReceive(pendingPacket);
	}

	for (Player* player : players)
	{
		player->ps->update(deltaTime);
	}

	std::string log;

	log = getWindow().getName() + " by " + getName()
		+ "\n"
		+ "\n"
		+ "[FPS]: " + std::to_string(getWindow().getFPS())
		+ "\n"
		+ "\n[RENDERER]"
		+ "\nDraw calls: " + std::to_string(renderer.getDrawCallCount())
		+ "\nSprites   : " + std::to_string(renderer.getSpriteCount())
		+ "\n"
		+ "\n[PARTICLES]"
		+ "\nTotal count: " + std::to_string(ParticleSystem::TotalParticleCount)
		+ "\n";

	for (Player* player : players)
	{
		log += "\n>" + player->label.text().getString()
			//+ "\n c: " + std::to_string(player->ps->getParticleCount())
			+ "\n x: " + std::to_string(player->ps->emitterPos.x)
			+ "\n y: " + std::to_string(player->ps->emitterPos.y)
			+ "\n";
	}

	scene_log.text().setString(log);
}

void ParticleSystemPlayground::render()
{
	getWindow().clear();

	renderer.resetStats();

	getWindow().setView(view_main); ///////////////////////////////////

	renderer.begin();

	for (Player* player : players)
	{
		renderer.draw(player->ps);
	}

	renderer.end();

	getWindow().setView(view_hud); ////////////////////////////////////

	renderer.begin();

	renderer.draw(scene_log);

	renderer.end();

	getWindow().display();
}

void ParticleSystemPlayground::randomizeParticleColors(Player* player)
{
	player->ps->colorBegin = sf::Color(rand() & 255, rand() & 255, rand() & 255);
	player->ps->colorEnd = sf::Color(rand() & 255, rand() & 255, rand() & 255);

	conn.send(PacketCreator::Get().PlayerInfo(getClientParams(player), myScreen));
}

void ParticleSystemPlayground::setControlParticle(bool arg)
{
	if (arg)
	{
		getWindow().setMouseCursorVisible(false);

		getWindow().setMousePositionRelativeToWindowAndView(view_main.getCenter(), view_main);
		getWindow().pollEvent(dummyEvent);
	}
	else
	{
		getWindow().setMouseCursorVisible(true);
	}
}

Player* ParticleSystemPlayground::createPlayer(ClientID id, std::string name, ParticleSystem* ps, const sf::Texture& texture)
{
	Player* newPlayer = nullptr;

	// check if player already exists
	for (Player* player : players)
	{
		if (player->params.id == id)
		{
			newPlayer = player;
			delete newPlayer->ps;
		}
	}

	// create new player if they're not found
	if (newPlayer == nullptr)
	{
		players.push_back(new Player());

		newPlayer = players.back();
	}

	newPlayer->params.id = id;

	newPlayer->ps = ps;
	newPlayer->ps->setTexture(texture);

	newPlayer->label.text().setFont(*scene_log.text().getFont());
	newPlayer->label.text().setCharacterSize(15);
	newPlayer->label.text().setPosition(10, -10);
	newPlayer->label.text().setString(name);

	newPlayer->ps->add(newPlayer->label);

	if (id == Client::MYSELF)
	{
		me = newPlayer;
	}

	cout << "Player added! ID: " << id << endl;

	return newPlayer;
}

ClientParams ParticleSystemPlayground::getClientParams(const Player* player)
{
	ClientParams dcp;

	dcp.name = player->label.text().getString().toAnsiString();
	dcp.ps.colorBegin = player->ps->colorBegin;
	dcp.ps.colorEnd = player->ps->colorEnd;
	dcp.ps.emitterPos = player->ps->emitterPos;

	return dcp;
}

// NETWORK CALLBACKS

void ParticleSystemPlayground::onConnect()
{
	cout << "Connected to the server!" << endl;
}

void ParticleSystemPlayground::onReceive(const Packet& receivedPacket)
{

	//if (receivedPacket.mType != PLAYER_MOVE)
	cout << "R> " << receivedPacket.toString() << endl;


	switch (receivedPacket.mType)
	{
	case PLAYER_NEW:
	{
		Player* newPlayer = createPlayer(receivedPacket.get<ClientID>(0), receivedPacket.get(4), new Fireball(getWindow(), view_main), particleTexture);
		Cross crossDir = static_cast<Cross>(receivedPacket.get<int>(1));

		switch (crossDir)
		{
		case CROSS_LEFT:
			newPlayer->ps->emitterPos.x = getWindow().getSize().x + receivedPacket.get<float>(2);
			break;
		case CROSS_RIGHT:
			newPlayer->ps->emitterPos.x = 0 - receivedPacket.get<float>(2);
			break;
		}

		newPlayer->ps->emitterPos.y = receivedPacket.get<float>(3) * getWindow().getSize().y;

		newPlayer->ps->colorBegin = sf::Color(receivedPacket.get<sf::Uint32>(5), receivedPacket.get<sf::Uint32>(6), receivedPacket.get<sf::Uint32>(7), receivedPacket.get<sf::Uint32>(8));
		newPlayer->ps->colorEnd = sf::Color(receivedPacket.get<sf::Uint32>(9), receivedPacket.get<sf::Uint32>(10), receivedPacket.get<sf::Uint32>(11), receivedPacket.get<sf::Uint32>(12));
	}
	break;

	case PLAYER_DEL:
	{
		ClientID clientID = receivedPacket.get<ClientID>(0);

		for (std::vector<Player*>::iterator it = players.begin(); it != players.end();)
		{
			if ((*it)->params.id == clientID)
			{
				delete (*it)->ps;
				delete (*it);

				it = players.erase(it);

				cout << "R> Player removed! ID: " << clientID << endl;
				return;
			}
			else
			{
				++it;
			}
		}

		cout << "R> Player to remove not found! ID: " << clientID << endl;
	}
	break;

	case PLAYER_MOVE:
	{
		const ClientID pID = receivedPacket.get<ClientID>(2);

		for (Player* player : players)
		{
			if (player->params.id == pID)
			{
				player->ps->emitterPos.x += receivedPacket.get<float>(0);
				player->ps->emitterPos.y += receivedPacket.get<float>(1);
				return;
			}
		}
		break;
	}
	}
}

void ParticleSystemPlayground::onDisconnect()
{
	cerr << "Lost connection to server!" << endl;
}
